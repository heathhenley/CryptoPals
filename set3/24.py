# Set 3, challenge 24 - Create the MT19937 stream cipher and break it
import os
import random
import time

# This is from the MT19937 implementation in the previous challenges, just
# copy/pasta it here because I don't think we'll need it other places

class MT19937:

  # buncha constants
  f = 1812433253
  w, n, m, r = 32, 624, 397, 31
  a = 0x9908B0DF
  u, d = 11, 0xFFFFFFFF
  s, b = 7, 0x9D2C5680
  t, c = 15, 0xEFC60000
  l = 18

  def __init__(self, seed: int):
    # init 
    self.MT = [0] * self.n  # state

    # masking for 32 bit ints 
    self.lower_mask = (1 << self.r) - 1
    self.upper_mask = (1 << self.r)

    # index
    self.index = self.n + 1

    # init state for the first time
    self.seed_mt(seed)
  
  def seed_mt(self, seed: int):
    # Initialize the generator from a seed
    self.index = self.n
    self.MT[0] = seed
    for i in range(1, self.n):
      self.MT[i] = self.f * (
        (self.MT[i-1] ^ (self.MT[i-1] >> (self.w-2))) + i)
      self.MT[i] &= self.lower_mask

  def extract_number(self):
    if self.index >= self.n:
      if self.index > self.n:
        raise Exception("Generator was never seeded")
      self._twist() 

    y = self.MT[self.index]
    y ^= (( y >> self.u) & self.d)
    y ^= (( y << self.s) & self.b)
    y ^= (( y << self.t) & self.c)
    y ^= ( y >> self.l)
    self.index += 1
    return y & self.lower_mask

  def _twist(self):
    for i in range(self.n):
      x = (self.MT[i] & self.upper_mask) | (
        self.MT[ (i+1) % self.n] & self.lower_mask )
      xA = x >> 1
      if x % 2 != 0:
        xA ^= self.a
      self.MT[i] = self.MT[(i + self.m) % self.n] ^ xA
    self.index = 0
  
  def getrandbits(self, k: int) -> int:
    # get k random bits
    if k <= 0:
      raise ValueError("number of bits must be greater than zero")
    if k <= 32:
      # just get the last k bits of the number
      return self.extract_number() & ((1 << k) - 1)
    # we need to get more than 32 bits so we need to get
    # multiple random numbers      
    res = 0
    for i in range(k // 32):
      res <<= 32
      res |= self.extract_number()
    return res & ((1 << k) - 1) 


# Make a stream cipher from the MT19937 PRNG with a 16-bit seed
def mt19937_stream_cipher_encrypt(seed: int, plaintext: bytes) -> bytes:
  # create the PRNG
  prng = MT19937(seed)
  # encrypt the plaintext
  ciphertext = b''
  for i in range(len(plaintext)):
    key = prng.getrandbits(8)
    ciphertext += bytes([plaintext[i] ^ key])
  return ciphertext

def mt19937_stream_cipher_decrypt(seed: int, ciphertext: bytes) -> bytes:
  """ It's the same but this is for clarity"""
  return mt19937_stream_cipher_encrypt(seed, ciphertext)


def break_mt19937_stream_cipher(
    ciphertext: bytes, known_plaintext: bytes, seed_size: int = 16) -> int:
  """ Brute for the seed by trying all possible values.

  Stop when the known_plaintext is found in the decrypted text. """
  for seed in range(2**16):
    decrypted = mt19937_stream_cipher_decrypt(seed, ciphertext)
    if known_plaintext in decrypted:
      print(f"Seed recovered: {seed}")
      return seed
  return None


def part1(seed_size: int = 16):
  """ seed size adjustable just to make it run faster for testing """

  print("Part 1")
  # get random 16-bit seed
  seed = random.randint(0, 2**seed_size - 1)
  print(f"Seed: {seed}")

  known_plaintext = b"Hello world! This a password_reset_token."
  prefix_len = random.randint(0, 50)
  prefix = prefix_len * os.urandom(1)
  print(f"Prefix: {prefix}")

  plain_text = prefix + known_plaintext
  print(f"Plaintext: {plain_text}")

  # encrypt the plaintext
  ciphertext = mt19937_stream_cipher_encrypt(seed, plain_text)
  print(f"Ciphertext: {ciphertext}")

  # recover the seed (brute force)
  seed_recovered = break_mt19937_stream_cipher(
    ciphertext, known_plaintext, seed_size=seed_size)
  if seed_recovered == seed:
    print("Seed recovered successfully")
  else:
    print("Seed recovery failed")


def part2(seed_size: int = 16):
  print("\nPart 2")
  # create a password reset token with the current time as seed

  # get the current time as seed and mask to seed_size bits
  seed = int(time.time()) & (2**seed_size - 1)
  print(f"Seed: {seed}")

  # create the password reset token
  prefix_len = random.randint(0, 50)
  prefix = prefix_len * os.urandom(1)
  token_text = prefix + b"password_reset_token=true&user_id=1234"
  token = mt19937_stream_cipher_encrypt(seed, token_text)
  print(f"Token: {token}")

  # check if a given token might have actually been generated by the PRNG with
  # the current time as seed (obviously it has here, this is basically the same
  # as the previous part)
  seed_recovered = break_mt19937_stream_cipher(
    token, b"password_reset_token=true", seed_size=seed_size)
  if seed_recovered == seed:
    print("Token was generated by the PRNG with the current time as seed")
    print(f"Decryted: {mt19937_stream_cipher_decrypt(seed, token)}")
  else:
    print("Token was not generated by the PRNG with the current time as seed")


def main():
  # from the challenge text
  # part 1:
  #   - encrypt known plaintext prefixed with a random number of random chars
  #   - from the ciphertext, recover the "key" (the seed used for the PRNG)
  part1(seed_size=8)
  # part 2:
  #   - use the same idea to generate a random "password reset token" using the
  #     current time as the seed
  #   - write a function to check if a given "password reset token" is actually
  #     valid the produce of MT19937 PRNG with the current time as seed
  part2(seed_size=8)


if __name__ == "__main__":
  main()
