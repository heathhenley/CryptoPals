import hmac
import time
import random
# Set 3 Challenge 21 + 22
# implement MT19937
# https://en.wikipedia.org/wiki/Mersenne_Twister
# then crack a poorly seeded MT19937
#
# Note: I'm using HMACs computed with RNG output as the key instead of the raw
# numbers generated by the RNG, because it's relevant to another challenge I'm
# working on

class MT19937:

  # buncha constants
  f = 1812433253
  w, n, m, r = 32, 624, 397, 31
  a = 0x9908B0DF
  u, d = 11, 0xFFFFFFFF
  s, b = 7, 0x9D2C5680
  t, c = 15, 0xEFC60000
  l = 18

  def __init__(self, seed: int):
    # init 
    self.MT = [0] * self.n  # state

    # masking for 32 bit ints 
    self.lower_mask = (1 << self.r) - 1
    self.upper_mask = (1 << self.r)

    # index
    self.index = self.n + 1

    # init state for the first time
    self.seed_mt(seed)
  
  def seed_mt(self, seed: int):
    # Initialize the generator from a seed
    self.index = self.n
    self.MT[0] = seed
    for i in range(1, self.n):
      self.MT[i] = self.f * (
        (self.MT[i-1] ^ (self.MT[i-1] >> (self.w-2))) + i)
      self.MT[i] &= self.lower_mask

  def extract_number(self):
    if self.index >= self.n:
      if self.index > self.n:
        raise Exception("Generator was never seeded")
      self._twist() 

    y = self.MT[self.index]
    y ^= (( y >> self.u) & self.d)
    y ^= (( y << self.s) & self.b)
    y ^= (( y << self.t) & self.c)
    y ^= ( y >> self.l)
    self.index += 1
    return y & self.lower_mask

  def _twist(self):
    for i in range(self.n):
      x = (self.MT[i] & self.upper_mask) | (
        self.MT[ (i+1) % self.n] & self.lower_mask )
      xA = x >> 1
      if x % 2 != 0:
        xA ^= self.a
      self.MT[i] = self.MT[(i + self.m) % self.n] ^ xA
    self.index = 0
  
  def getrandbits(self, k: int) -> int:
    # get k random bits
    if k <= 0:
      raise ValueError("number of bits must be greater than zero")
    if k <= 32:
      # just get the last k bits of the number
      return self.extract_number() & ((1 << k) - 1)
    # we need to get more than 32 bits so we need to get
    # multiple random numbers      
    res = 0
    for i in range(k // 32):
      res <<= 32
      res |= self.extract_number()
    return res & ((1 << k) - 1) 


def main():
  mt = MT19937(0)
  for _ in range(10):
    print(f"{mt.getrandbits(16):016b}")


# oracle like function to generate a random key and hmac of a message that
# uses a poorly seeded mt19937 and that us "uknown" to the attacker
def hmac_md5_random_key(
    msg: bytes, max_time_delta: int, max_iters: int) -> str:
  # generate a random key and use it to generate an hmac of the message, but
  # our MT is seeded with the current time some time in the past, and has been
  # some random number of times
  seed = int(time.time()) - random.randint(1, max_time_delta)
  mt = MT19937(seed)
  
  # extract some numbers to make things more difficult
  for _ in range(random.randint(0, max_iters)):
    mt.extract_number()

  # actual random key
  key = mt.getrandbits(256)
  return hmac.new(key.to_bytes(32), msg, digestmod="md5").hexdigest(), seed


def get_valid_keys(vals: list, key_size: int) -> list:
  # the key is 256 bits, so if someone pulled another number from the rng
  # in between generating the key, we might miss it when we try to brute force
  # because if we simply call getrandbits(256) we will pull 8 numbers from the
  # rng - we will only detect the right seed in multiples of 8 unless we try
  # all the possible offsets

  assert key_size % 32 == 0, "key size must be a multiple of 32 - for now"

  # we need to try all the possible offsets to make key_size bits
  total_bits = len(vals) * 32
  vals_in_key = key_size // 32

  # start with any val as the first one
  for i in range(len(vals)-vals_in_key+1):
    key = vals[i]
    for j in range(1, vals_in_key):
      key <<= 32
      key |= vals[i+j]
    yield key


def test_attack():
  # Test attack - More or less, this is Set 3 Challenge 22
  # I've modified it to practice for another challenge, eg using HMACs instead
  # of only the numbers generated by the RNG


  # For testing:
  #  - unknown random key (256 bits) using a poorly seeded mt19937
  #  - use it to HMAC our test message 
  #  - we don't know the key, or how many times the RNG was called before we
  #    the key was generated, but we know it was seeded 'poorly', and that it
  #    is MT19937 obviously

  msg = b"this is a test message"
  target, actual_seed = hmac_md5_random_key(
    msg, max_time_delta=500, max_iters=500)
  print(f"msg:mac - {msg.decode()}:{target}")
  print("actual seed: ", actual_seed)

  # Brute force the RNG seed and key:
  # How many numbers to pull for each seed - we pull this many 32 bit numbers
  # from the rng and use them to generate a key, but we need to make sure we
  # try all possible offsets in there - if we only calling getrandbits(256),
  # we will only detect the right seed in multiples of 8 (assuming 32 bit ints)
  # so if someone called pull a couple more 32 bit ints from the rng we're
  # trying to crack, we would miss it
  extract_per_seed = 1000
  k = 0
  found = False
  # brute force the seed and key, start at now and go backwards
  for seed in range(int(time.time()), 0, -1):

    if found:
      break

    # set up with the seed we want to test
    mt = MT19937(seed)

    # how many numbers to pull for this seed

    vals = [mt.extract_number() for _ in range(extract_per_seed)]

    for key in get_valid_keys(vals, 256):

      k += 1
  
      # get hmac of plaintext using key (little endian)
      h = hmac.new(key.to_bytes(32, "little"), msg, digestmod="md5")
      if h.hexdigest() == target:
        print(f"found seed: {seed}, key: {key}, little endian")
        found = True
        break

      # get hmac of plaintext using key (big endian)
      h = hmac.new(key.to_bytes(32, "big"), msg, digestmod="md5")
      if h.hexdigest() == target:
        print(f"found seed: {seed}, key: {key}, big endian")
        found = True
        break

      if k % 100_000 == 0:
        print(k, seed, actual_seed)

      if seed < actual_seed:
        print("you missed it :(")


if __name__ == "__main__":
  #main()
  test_attack()